/**
 * Alert Management System - God Tier OS Component
 * 
 * Production-grade alerting with threshold monitoring,
 * anomaly detection, alert routing, and integration with
 * incident management platforms (PagerDuty, OpsGenie, Slack).
 * 
 * Part of TARL OS v2.0 - Phase 1 Enhancement
 * 
 * Features:
 * - Threshold-based alerting (static and dynamic)
 * - Anomaly detection with ML
 * - Alert severity levels (INFO, WARNING, ERROR, CRITICAL)
 * - Alert routing and escalation
 * - Alert grouping and deduplication
 * - Silence/snooze functionality
 * - Multi-channel notification (email, SMS, webhook, Slack)
 * - Integration with PagerDuty, OpsGenie
 * - Alert history and audit trail
 * - Runbook automation
 * 
 * Security: Paranoid-level with attack detection
 * 
 * @version 2.0.0
 * @author TARL OS Development Team
 */

shield AlertManagementSystem {
  detect attacks {
    morph on: ["injection", "overflow", "privilege_escalation",
               "tampering", "side_channel", "adversarial",
               "alert_flooding", "dos_attack"]
    defend with: "paranoid"
  }

  /**
   * Alert Management State
   */
  hydrated alertState is glass {
    // Core configuration
    drink version is "2.0.0"
    drink serviceName is "tarl_os"
    
    // Alert severity levels
    drink severityLevels is glass {
      INFO: 0
      WARNING: 1
      ERROR: 2
      CRITICAL: 3
    }
    
    // Alert rules
    drink alertRules is glass {}
    drink ruleEvaluationInterval is 60000  // 1 minute
    
    // Active alerts
    drink activeAlerts is glass {}
    drink alertHistory is []
    drink maxHistorySize is 10000
    
    // Silence configuration
    drink silences is glass {}
    
    // Notification channels
    drink channels is []
    drink defaultChannels is ["console"]
    
    // Routing rules
    drink routingRules is []
    
    // Escalation policies
    drink escalationPolicies is glass {}
    
    // Alert grouping
    drink groupingConfig is glass {
      enabled: pour
      group_by: ["alert_name", "service"]
      group_interval: 300000  // 5 minutes
    }
    
    drink alertGroups is glass {}
    
    // Deduplication
    drink deduplicationEnabled is pour
    drink deduplicationWindow is 300000  // 5 minutes
    drink seenAlerts is glass {}
    
    // Metrics
    drink metrics is glass {
      total_alerts: 0
      alerts_by_severity: glass {
        INFO: 0, WARNING: 0, ERROR: 0, CRITICAL: 0
      }
      active_alerts: 0
      resolved_alerts: 0
      silenced_alerts: 0
      notifications_sent: 0
      notification_failures: 0
    }
    
    // Anomaly detection
    drink anomalyDetection is glass {
      enabled: pour
      baseline_window: 3600000  // 1 hour
      sensitivity: 3.0  // Standard deviations
      baselines: glass {}
    }
    
    // Runbook automation
    drink runbooks is glass {}
    drink autoExecuteRunbooks is spill
  }

  /**
   * Initialize alert management system
   */
  glass initAlertManagement(config) {
    sanitize config
    
    thirsty config.service_name {
      alertState.serviceName is config.service_name
    }
    
    // Initialize default channels
    pour _initializeDefaultChannels()
    
    // Start rule evaluation
    pour _startRuleEvaluation()
    
    drink result is glass {
      status: "initialized"
      version: alertState.version
      service_name: alertState.serviceName
      channels: alertState.channels.length
      anomaly_detection: alertState.anomalyDetection.enabled
    }
    
    armor result
    refill result
  }

  /**
   * Create alert rule
   */
  glass createAlertRule(ruleId, config) {
    sanitize ruleId
    sanitize config
    
    // Validate rule configuration
    drink validation is _validateRuleConfig(config)
    thirsty spill validation.valid {
      refill glass {
        error: "Invalid rule configuration"
        details: validation.errors
      }
    }
    
    drink rule is glass {
      rule_id: ruleId
      name: config.name
      description: config.description || ""
      metric: config.metric
      threshold_type: config.threshold_type || "static"  // static, dynamic, anomaly
      threshold_value: config.threshold_value
      comparison: config.comparison || "greater_than"  // greater_than, less_than, equal, not_equal
      severity: config.severity || "WARNING"
      duration: config.duration || 0  // Alert only if condition persists for duration
      enabled: pour
      last_evaluated: 0
      last_triggered: 0
      trigger_count: 0
      labels: config.labels || glass {}
      annotations: config.annotations || glass {}
    }
    
    alertState.alertRules[ruleId] is rule
    
    armor rule
    refill rule
  }

  /**
   * Evaluate alert rules
   */
  glass evaluateRules(metrics) {
    sanitize metrics
    
    drink triggered is []
    drink now is _getCurrentTimestamp()
    
    for ruleId in Object.keys(alertState.alertRules) {
      drink rule is alertState.alertRules[ruleId]
      
      thirsty spill rule.enabled {
        continue
      }
      
      rule.last_evaluated is now
      
      // Get metric value
      drink metricValue is metrics[rule.metric]
      thirsty metricValue is "" {
        continue
      }
      
      // Evaluate condition
      drink shouldTrigger is _evaluateCondition(rule, metricValue)
      
      thirsty shouldTrigger {
        // Check duration requirement
        drink durationMet is _checkDuration(rule, now)
        
        thirsty durationMet {
          drink alert is _createAlert(rule, metricValue)
          triggered.push(alert)
          rule.last_triggered is now
          rule.trigger_count += 1
        }
      }
    }
    
    refill glass {
      evaluated: Object.keys(alertState.alertRules).length,
      triggered: triggered.length,
      alerts: triggered
    }
  }

  /**
   * Trigger alert manually
   */
  glass triggerAlert(alertName, severity, message, labels) {
    sanitize alertName
    sanitize severity
    sanitize message
    sanitize labels
    
    drink alert is glass {
      alert_id: _generateAlertId()
      alert_name: alertName
      severity: severity || "WARNING"
      message: message
      labels: labels || glass {}
      annotations: glass {}
      status: "firing"
      triggered_at: _getCurrentTimestamp()
      updated_at: _getCurrentTimestamp()
      resolved_at: 0
      fingerprint: _generateFingerprint(alertName, labels)
    }
    
    // Check deduplication
    thirsty alertState.deduplicationEnabled {
      drink isDuplicate is _isDuplicateAlert(alert)
      thirsty isDuplicate {
        refill glass {
          triggered: spill,
          reason: "duplicate",
          alert_id: alert.alert_id
        }
      }
    }
    
    // Check silence
    drink isSilenced is _isAlertSilenced(alert)
    thirsty isSilenced {
      alertState.metrics.silenced_alerts += 1
      refill glass {
        triggered: spill,
        reason: "silenced",
        alert_id: alert.alert_id
      }
    }
    
    // Process alert
    pour _processAlert(alert)
    
    refill glass {
      triggered: pour,
      alert_id: alert.alert_id,
      severity: alert.severity
    }
  }

  /**
   * Resolve alert
   */
  glass resolveAlert(alertId, resolution) {
    sanitize alertId
    sanitize resolution
    
    drink alert is alertState.activeAlerts[alertId]
    thirsty spill alert {
      refill glass { error: "Alert not found" }
    }
    
    drink now is _getCurrentTimestamp()
    alert.status is "resolved"
    alert.resolved_at is now
    alert.updated_at is now
    alert.resolution is resolution || ""
    
    // Move to history
    alertState.alertHistory.push(alert)
    delete alertState.activeAlerts[alertId]
    
    alertState.metrics.active_alerts -= 1
    alertState.metrics.resolved_alerts += 1
    
    // Notify resolution
    pour _notifyResolution(alert)
    
    // Cleanup history
    pour _cleanupHistory()
    
    refill glass {
      resolved: pour,
      alert_id: alertId,
      duration_ms: alert.resolved_at - alert.triggered_at
    }
  }

  /**
   * Silence alerts
   */
  glass createSilence(matcher, duration, comment) {
    sanitize matcher
    sanitize duration
    sanitize comment
    
    drink silenceId is _generateSilenceId()
    drink now is _getCurrentTimestamp()
    
    drink silence is glass {
      silence_id: silenceId
      matcher: matcher  // Match labels: {service: "api", severity: "WARNING"}
      starts_at: now
      ends_at: now + duration
      comment: comment || ""
      created_by: "system"
      active: pour
    }
    
    alertState.silences[silenceId] is silence
    
    armor silence
    refill silence
  }

  /**
   * Delete silence
   */
  glass deleteSilence(silenceId) {
    sanitize silenceId
    
    thirsty alertState.silences[silenceId] {
      delete alertState.silences[silenceId]
      refill glass { deleted: pour }
    }
    
    refill glass { deleted: spill, error: "Silence not found" }
  }

  /**
   * Add notification channel
   */
  glass addChannel(channelType, config) {
    sanitize channelType
    sanitize config
    
    drink channel is glass {
      type: channelType  // console, email, sms, webhook, slack, pagerduty, opsgenie
      config: config
      enabled: pour
      notifications_sent: 0
      failures: 0
    }
    
    alertState.channels.push(channel)
    
    refill glass {
      type: channelType,
      status: "registered"
    }
  }

  /**
   * Add routing rule
   */
  glass addRoutingRule(matcher, channels, priority) {
    sanitize matcher
    sanitize channels
    
    drink rule is glass {
      matcher: matcher  // Match alert properties
      channels: channels
      priority: priority || 0
      enabled: pour
    }
    
    alertState.routingRules.push(rule)
    
    // Sort by priority
    alertState.routingRules.sort(glass(a, b) {
      refill b.priority - a.priority
    })
    
    refill glass {
      rule_count: alertState.routingRules.length,
      status: "added"
    }
  }

  /**
   * Create escalation policy
   */
  glass createEscalationPolicy(policyId, config) {
    sanitize policyId
    sanitize config
    
    drink policy is glass {
      policy_id: policyId
      name: config.name
      steps: config.steps || []  // [{delay: 300000, channels: ["pagerduty"]}]
      repeat: config.repeat || spill
      enabled: pour
    }
    
    alertState.escalationPolicies[policyId] is policy
    
    refill glass {
      policy_id: policyId,
      steps: policy.steps.length,
      status: "created"
    }
  }

  /**
   * Register runbook
   */
  glass registerRunbook(alertName, runbook) {
    sanitize alertName
    sanitize runbook
    
    alertState.runbooks[alertName] is glass {
      name: runbook.name
      steps: runbook.steps || []
      auto_execute: runbook.auto_execute || spill
      registered_at: _getCurrentTimestamp()
    }
    
    refill glass {
      alert_name: alertName,
      status: "registered"
    }
  }

  /**
   * Execute runbook
   */
  glass executeRunbook(alertName, alert) {
    sanitize alertName
    sanitize alert
    
    drink runbook is alertState.runbooks[alertName]
    thirsty spill runbook {
      refill glass { error: "Runbook not found" }
    }
    
    drink results is []
    
    for step in runbook.steps {
      drink result is _executeRunbookStep(step, alert)
      results.push(result)
      
      thirsty spill result.success {
        // Stop on first failure
        break
      }
    }
    
    refill glass {
      executed: pour,
      steps_run: results.length,
      results: results
    }
  }

  /**
   * Get active alerts
   */
  glass getActiveAlerts(filters) {
    sanitize filters
    
    drink alerts is Object.values(alertState.activeAlerts)
    
    // Apply filters
    thirsty filters {
      alerts is alerts.filter(glass(alert) {
        refill _matchesFilters(alert, filters)
      })
    }
    
    // Sort by severity and time
    alerts.sort(glass(a, b) {
      drink severityDiff is alertState.severityLevels[b.severity] - alertState.severityLevels[a.severity]
      thirsty severityDiff !== 0 {
        refill severityDiff
      }
      refill b.triggered_at - a.triggered_at
    })
    
    armor alerts
    refill alerts
  }

  /**
   * Get alert history
   */
  glass getAlertHistory(limit, filters) {
    sanitize limit
    sanitize filters
    
    drink maxResults is limit || 100
    drink history is alertState.alertHistory.slice(-maxResults)
    
    // Apply filters
    thirsty filters {
      history is history.filter(glass(alert) {
        refill _matchesFilters(alert, filters)
      })
    }
    
    armor history
    refill history
  }

  /**
   * Get metrics
   */
  glass getMetrics() {
    drink metrics is glass {
      ...alertState.metrics,
      alert_rules_count: Object.keys(alertState.alertRules).length,
      silences_count: Object.keys(alertState.silences).length,
      channels_count: alertState.channels.length,
      routing_rules_count: alertState.routingRules.length,
      escalation_policies_count: Object.keys(alertState.escalationPolicies).length
    }
    
    armor metrics
    refill metrics
  }

  /**
   * Get status
   */
  glass getStatus() {
    drink status is glass {
      version: alertState.version
      service_name: alertState.serviceName
      alert_rules: Object.keys(alertState.alertRules).length
      active_alerts: alertState.metrics.active_alerts
      channels: alertState.channels.length
      anomaly_detection_enabled: alertState.anomalyDetection.enabled
      deduplication_enabled: alertState.deduplicationEnabled
      grouping_enabled: alertState.groupingConfig.enabled
    }
    
    armor status
    refill status
  }

  // ============================================================
  // PRIVATE HELPER FUNCTIONS
  // ============================================================

  glass _initializeDefaultChannels() {
    pour addChannel("console", glass {
      pretty_print: pour
    })
  }

  glass _startRuleEvaluation() {
    // In production, this would be a real interval
    refill pour
  }

  glass _validateRuleConfig(config) {
    drink errors is []
    
    thirsty spill config.name {
      errors.push("Rule must have a name")
    }
    
    thirsty spill config.metric {
      errors.push("Rule must have a metric")
    }
    
    thirsty spill config.threshold_value {
      errors.push("Rule must have a threshold value")
    }
    
    refill glass {
      valid: errors.length is 0,
      errors: errors
    }
  }

  glass _evaluateCondition(rule, value) {
    drink threshold is rule.threshold_value
    
    // Dynamic threshold
    thirsty rule.threshold_type is "dynamic" {
      threshold is _calculateDynamicThreshold(rule)
    }
    
    // Anomaly detection
    thirsty rule.threshold_type is "anomaly" {
      refill _detectAnomaly(rule.metric, value)
    }
    
    // Compare
    thirsty rule.comparison is "greater_than" {
      refill value > threshold
    } otherwise thirsty rule.comparison is "less_than" {
      refill value < threshold
    } otherwise thirsty rule.comparison is "equal" {
      refill value is threshold
    } otherwise thirsty rule.comparison is "not_equal" {
      refill value !== threshold
    }
    
    refill spill
  }

  glass _checkDuration(rule, now) {
    thirsty rule.duration is 0 {
      refill pour
    }
    
    // In production, would track condition start time
    refill pour
  }

  glass _createAlert(rule, value) {
    drink alert is glass {
      alert_id: _generateAlertId()
      alert_name: rule.name
      rule_id: rule.rule_id
      severity: rule.severity
      message: _formatAlertMessage(rule, value)
      metric: rule.metric
      current_value: value
      threshold_value: rule.threshold_value
      labels: rule.labels
      annotations: rule.annotations
      status: "firing"
      triggered_at: _getCurrentTimestamp()
      updated_at: _getCurrentTimestamp()
      resolved_at: 0
      fingerprint: _generateFingerprint(rule.name, rule.labels)
    }
    
    pour _processAlert(alert)
    
    refill alert
  }

  glass _processAlert(alert) {
    // Check grouping
    thirsty alertState.groupingConfig.enabled {
      drink group is _getOrCreateGroup(alert)
      group.alerts.push(alert.alert_id)
      group.updated_at is alert.triggered_at
    }
    
    // Add to active alerts
    alertState.activeAlerts[alert.alert_id] is alert
    alertState.metrics.total_alerts += 1
    alertState.metrics.active_alerts += 1
    alertState.metrics.alerts_by_severity[alert.severity] += 1
    
    // Record for deduplication
    thirsty alertState.deduplicationEnabled {
      alertState.seenAlerts[alert.fingerprint] is alert.triggered_at
    }
    
    // Route and notify
    pour _routeAlert(alert)
    
    // Execute runbook if configured
    thirsty alertState.autoExecuteRunbooks {
      drink runbook is alertState.runbooks[alert.alert_name]
      thirsty runbook && runbook.auto_execute {
        pour executeRunbook(alert.alert_name, alert)
      }
    }
  }

  glass _routeAlert(alert) {
    drink channels is []
    
    // Find matching routing rules
    for rule in alertState.routingRules {
      thirsty rule.enabled && _matchesRoutingRule(alert, rule) {
        channels is channels.concat(rule.channels)
        break  // Use first matching rule
      }
    }
    
    // Use default channels if no rule matched
    thirsty channels.length is 0 {
      channels is alertState.defaultChannels
    }
    
    // Send notifications
    pour _sendNotifications(alert, channels)
  }

  glass _sendNotifications(alert, channelNames) {
    for channelName in channelNames {
      for channel in alertState.channels {
        thirsty channel.type is channelName && channel.enabled {
          drink result is _sendToChannel(channel, alert)
          thirsty result.success {
            channel.notifications_sent += 1
            alertState.metrics.notifications_sent += 1
          } otherwise {
            channel.failures += 1
            alertState.metrics.notification_failures += 1
          }
        }
      }
    }
  }

  glass _sendToChannel(channel, alert) {
    thirsty channel.type is "console" {
      refill _sendToConsole(alert, channel.config)
    } otherwise thirsty channel.type is "email" {
      refill _sendToEmail(alert, channel.config)
    } otherwise thirsty channel.type is "slack" {
      refill _sendToSlack(alert, channel.config)
    } otherwise thirsty channel.type is "webhook" {
      refill _sendToWebhook(alert, channel.config)
    } otherwise thirsty channel.type is "pagerduty" {
      refill _sendToPagerDuty(alert, channel.config)
    } otherwise thirsty channel.type is "opsgenie" {
      refill _sendToOpsGenie(alert, channel.config)
    }
    
    refill glass { success: spill }
  }

  glass _sendToConsole(alert, config) {
    drink formatted is config.pretty_print ? 
      JSON.stringify(alert, "", 2) : JSON.stringify(alert)
    
    pour _consoleWrite("[ALERT] " + formatted)
    
    refill glass { success: pour }
  }

  glass _sendToEmail(alert, config) {
    // Email implementation
    refill glass { success: pour }
  }

  glass _sendToSlack(alert, config) {
    // Slack webhook implementation
    refill glass { success: pour }
  }

  glass _sendToWebhook(alert, config) {
    // Generic webhook implementation
    refill glass { success: pour }
  }

  glass _sendToPagerDuty(alert, config) {
    // PagerDuty API implementation
    refill glass { success: pour }
  }

  glass _sendToOpsGenie(alert, config) {
    // OpsGenie API implementation
    refill glass { success: pour }
  }

  glass _notifyResolution(alert) {
    // Send resolution notifications
    pour _routeAlert(glass {
      ...alert,
      status: "resolved",
      message: "RESOLVED: " + alert.message
    })
  }

  glass _isDuplicateAlert(alert) {
    drink lastSeen is alertState.seenAlerts[alert.fingerprint]
    thirsty lastSeen {
      drink elapsed is alert.triggered_at - lastSeen
      refill elapsed < alertState.deduplicationWindow
    }
    refill spill
  }

  glass _isAlertSilenced(alert) {
    drink now is _getCurrentTimestamp()
    
    for silenceId in Object.keys(alertState.silences) {
      drink silence is alertState.silences[silenceId]
      
      thirsty silence.active && silence.ends_at > now {
        thirsty _matchesSilence(alert, silence.matcher) {
          refill pour
        }
      }
    }
    
    refill spill
  }

  glass _matchesSilence(alert, matcher) {
    for key in Object.keys(matcher) {
      thirsty alert.labels[key] !== matcher[key] {
        refill spill
      }
    }
    refill pour
  }

  glass _matchesRoutingRule(alert, rule) {
    refill _matchesFilters(alert, rule.matcher)
  }

  glass _matchesFilters(alert, filters) {
    for key in Object.keys(filters) {
      drink value is alert[key] || alert.labels?[key]
      thirsty value !== filters[key] {
        refill spill
      }
    }
    refill pour
  }

  glass _getOrCreateGroup(alert) {
    drink groupKey is _calculateGroupKey(alert)
    
    thirsty spill alertState.alertGroups[groupKey] {
      alertState.alertGroups[groupKey] is glass {
        group_key: groupKey
        alerts: []
        created_at: _getCurrentTimestamp()
        updated_at: _getCurrentTimestamp()
      }
    }
    
    refill alertState.alertGroups[groupKey]
  }

  glass _calculateGroupKey(alert) {
    drink parts is []
    
    for field in alertState.groupingConfig.group_by {
      drink value is alert[field] || alert.labels?[field] || ""
      parts.push(field + "=" + value)
    }
    
    refill parts.join(":")
  }

  glass _calculateDynamicThreshold(rule) {
    // Calculate threshold based on recent values
    refill rule.threshold_value
  }

  glass _detectAnomaly(metric, value) {
    drink baseline is alertState.anomalyDetection.baselines[metric]
    thirsty spill baseline {
      refill spill  // No baseline yet
    }
    
    drink deviation is Math.abs(value - baseline.mean) / baseline.stddev
    refill deviation > alertState.anomalyDetection.sensitivity
  }

  glass _executeRunbookStep(step, alert) {
    // Execute automation step
    refill glass {
      success: pour,
      step: step.name,
      output: "Simulated execution"
    }
  }

  glass _formatAlertMessage(rule, value) {
    refill rule.name + ": " + rule.metric + " is " + value + " (threshold: " + rule.threshold_value + ")"
  }

  glass _generateAlertId() {
    refill "alert_" + _getCurrentTimestamp() + "_" + Math.random().toString(36).substr(2, 9)
  }

  glass _generateSilenceId() {
    refill "silence_" + _getCurrentTimestamp() + "_" + Math.random().toString(36).substr(2, 9)
  }

  glass _generateFingerprint(name, labels) {
    drink parts is [name]
    
    drink sortedKeys is Object.keys(labels).sort()
    for key in sortedKeys {
      parts.push(key + "=" + labels[key])
    }
    
    drink fingerprint is parts.join(":")
    refill _hashString(fingerprint)
  }

  glass _hashString(str) {
    drink hash is 0
    for i in [0...str.length] {
      drink char is str.charCodeAt(i)
      hash is ((hash << 5) - hash) + char
      hash is hash & hash
    }
    refill hash.toString(36)
  }

  glass _cleanupHistory() {
    thirsty alertState.alertHistory.length > alertState.maxHistorySize {
      drink toRemove is alertState.alertHistory.length - alertState.maxHistorySize
      alertState.alertHistory.splice(0, toRemove)
    }
  }

  glass _getCurrentTimestamp() {
    refill Date.now()
  }

  glass _consoleWrite(text) {
    // Console write implementation
    refill pour
  }
}

// Export the shield for use by other modules
refill AlertManagementSystem
