name: Auto-Create Branch PRs

on:
  # Run daily to check for new branches
  schedule:
    - cron: '0 2 * * *'  # 2 AM UTC daily
  
  # Manual trigger
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Specific branch to create PR for (leave empty for all branches)'
        required: false
        default: ''
  
  # Trigger when new branches are pushed
  push:
    branches-ignore:
      - main
      - 'dependabot/**'
  
  # Also trigger on pull_request events to ensure coordination
  pull_request:
    types: [closed]

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: write
  statuses: write

jobs:
  discover-and-create-prs:
    name: Discover Branches and Create PRs
    runs-on: ubuntu-latest
    outputs:
      branches: ${{ steps.get-branches.outputs.branches }}
      branch-count: ${{ steps.get-branches.outputs.count }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for all branches

      - name: Set up Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Fetch all branches
        run: |
          git fetch --all --prune

      - name: Get all non-main branches
        id: get-branches
        uses: actions/github-script@v7
        with:
          script: |
            const targetBranch = '${{ github.event.inputs.target_branch }}';
            
            // Get all branches with pagination
            let allBranches = [];
            let page = 1;
            let hasMore = true;
            
            while (hasMore) {
              const { data: branches } = await github.rest.repos.listBranches({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100,
                page: page
              });
              
              allBranches = allBranches.concat(branches);
              hasMore = branches.length === 100;
              page++;
              
              if (page > 10) {  // Safety limit: max 1000 branches
                console.log('Warning: Reached maximum branch limit (1000)');
                break;
              }
            }
            
            console.log(`Found ${allBranches.length} total branches`);
            
            // Get all open PRs with pagination
            let allPRs = [];
            page = 1;
            hasMore = true;
            
            while (hasMore) {
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100,
                page: page
              });
              
              allPRs = allPRs.concat(prs);
              hasMore = prs.length === 100;
              page++;
              
              if (page > 10) {  // Safety limit: max 1000 PRs
                console.log('Warning: Reached maximum PR limit (1000)');
                break;
              }
            }
            
            // Create a set of branches that already have open PRs
            const branchesWithPRs = new Set(allPRs.map(pr => pr.head.ref));
            
            // Filter branches
            let branchesToProcess = allBranches
              .map(b => b.name)
              .filter(name => {
                // Skip main branch
                if (name === 'main') return false;
                
                // Skip bot-generated branches
                if (name.startsWith('dependabot/')) return false;
                if (name.startsWith('renovate/')) return false;
                if (name.startsWith('snyk-')) return false;
                
                // Skip if already has open PR
                if (branchesWithPRs.has(name)) {
                  console.log(`Skipping ${name} - already has open PR`);
                  return false;
                }
                
                // If specific branch requested, only process that one
                if (targetBranch && name !== targetBranch) return false;
                
                return true;
              });
            
            console.log(`Found ${branchesToProcess.length} branches to process:`, branchesToProcess);
            
            core.setOutput('branches', JSON.stringify(branchesToProcess));
            core.setOutput('count', branchesToProcess.length);
            
            return branchesToProcess;

      - name: Create summary
        run: |
          echo "## Branch Discovery Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Branches found:** ${{ steps.get-branches.outputs.count }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.get-branches.outputs.count }}" -gt 0 ]; then
            echo "PRs will be created for these branches in the next job." >> $GITHUB_STEP_SUMMARY
          else
            echo "No branches need PR creation." >> $GITHUB_STEP_SUMMARY
          fi

  create-prs:
    name: Create PR for Branch
    runs-on: ubuntu-latest
    needs: discover-and-create-prs
    if: needs.discover-and-create-prs.outputs.branch-count > 0
    strategy:
      matrix:
        branch: ${{ fromJson(needs.discover-and-create-prs.outputs.branches) }}
      max-parallel: 5  # Process 5 branches at a time
      fail-fast: false  # Continue even if one fails
    steps:
      - name: Checkout branch
        uses: actions/checkout@v4
        with:
          ref: ${{ matrix.branch }}
          fetch-depth: 0

      - name: Set up Git identity
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Check for merge conflicts with main
        id: conflict-check
        run: |
          git fetch origin main
          
          # Try to merge main into current branch (no commit, dry run)
          git merge origin/main --no-commit --no-ff 2>&1 || true
          
          # Check if there are unmerged files (conflicts)
          if git diff --name-only --diff-filter=U | grep -q .; then
            echo "conflict=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Merge conflicts detected with main"
            # Abort the merge attempt
            git merge --abort
          else
            echo "conflict=false" >> $GITHUB_OUTPUT
            echo "‚úÖ No conflicts with main"
            # Abort the merge if we started one
            git merge --abort 2>/dev/null || true
          fi

      - name: Attempt auto-resolve conflicts
        if: steps.conflict-check.outputs.conflict == 'true'
        run: |
          echo "Attempting to auto-resolve conflicts..."
          
          # Merge main into current branch
          git merge origin/main --no-commit --no-ff || true
          
          # Check for conflicts
          if git diff --name-only --diff-filter=U | grep -q .; then
            echo "CONFLICTS_PRESENT=true" >> $GITHUB_ENV
            
            # List conflicted files
            echo "Conflicted files:"
            git diff --name-only --diff-filter=U
            
            # Abort the merge
            git merge --abort
          else
            echo "CONFLICTS_PRESENT=false" >> $GITHUB_ENV
            echo "Conflicts auto-resolved successfully"
            
            # Commit the merge
            git commit -m "chore: merge main to resolve conflicts [automated]"
            git push origin ${{ matrix.branch }}
          fi

      - name: Get branch info
        id: branch-info
        uses: actions/github-script@v7
        with:
          script: |
            const branch = '${{ matrix.branch }}';
            
            // Get commits on this branch not in main
            const { data: comparison } = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: 'main',
              head: branch
            });
            
            const commitCount = comparison.ahead_by;
            const behindBy = comparison.behind_by;
            
            // CRITICAL FIX: Skip if branch has no commits ahead of main
            if (commitCount === 0) {
              console.log(`‚ö†Ô∏è Branch ${branch} has 0 commits ahead of main - skipping PR creation`);
              core.setOutput('skip_pr', 'true');
              core.setOutput('commit_count', '0');
              core.setOutput('behind_by', behindBy);
              core.setOutput('days_old', '0');
              core.setOutput('last_commit_message', '');
              return { skip: true, reason: 'no_commits_ahead' };
            }
            
            // Get last commit on branch
            const { data: commits } = await github.rest.repos.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: branch,
              per_page: 1
            });
            
            const lastCommit = commits[0];
            const lastCommitDate = new Date(lastCommit.commit.author.date);
            const daysSinceLastCommit = Math.floor((Date.now() - lastCommitDate) / (1000 * 60 * 60 * 24));
            
            core.setOutput('skip_pr', 'false');
            core.setOutput('commit_count', commitCount);
            core.setOutput('behind_by', behindBy);
            core.setOutput('days_old', daysSinceLastCommit);
            core.setOutput('last_commit_message', lastCommit.commit.message.split('\n')[0]);
            
            return {
              commitCount,
              behindBy,
              daysSinceLastCommit,
              lastCommitMessage: lastCommit.commit.message.split('\n')[0]
            };

      - name: Generate PR title and body
        id: pr-content
        if: steps.branch-info.outputs.skip_pr != 'true'
        run: |
          BRANCH="${{ matrix.branch }}"
          COMMIT_COUNT="${{ steps.branch-info.outputs.commit_count }}"
          BEHIND_BY="${{ steps.branch-info.outputs.behind_by }}"
          DAYS_OLD="${{ steps.branch-info.outputs.days_old }}"
          LAST_COMMIT="${{ steps.branch-info.outputs.last_commit_message }}"
          CONFLICTS="${{ env.CONFLICTS_PRESENT }}"
          
          # Generate title based on branch name
          if [[ "$BRANCH" == copilot/* ]]; then
            TITLE="[Auto] Merge ${BRANCH#copilot/}"
          elif [[ "$BRANCH" == feature/* ]]; then
            TITLE="[Auto] Feature: ${BRANCH#feature/}"
          elif [[ "$BRANCH" == fix/* ]]; then
            TITLE="[Auto] Fix: ${BRANCH#fix/}"
          else
            TITLE="[Auto] Merge branch: $BRANCH"
          fi
          
          # Generate body
          BODY="## ü§ñ Automated Pull Request
          
          This PR was automatically created by the **Auto-Create Branch PRs** workflow.
          
          ### Branch Information
          - **Branch**: \`$BRANCH\`
          - **Commits ahead of main**: $COMMIT_COUNT
          - **Commits behind main**: $BEHIND_BY
          - **Last commit**: $LAST_COMMIT
          - **Last updated**: $DAYS_OLD days ago
          
          ### Status Checks
          "
          
          if [ "$CONFLICTS" = "true" ]; then
            BODY="${BODY}
          - ‚ö†Ô∏è **Merge Conflicts**: Manual resolution required
          
          **Action Required**: This PR has merge conflicts with main that could not be auto-resolved. Please resolve conflicts manually.
          "
          else
            BODY="${BODY}
          - ‚úÖ **No Conflicts**: Ready for automated checks
          
          This PR will be automatically reviewed, tested, and merged if all checks pass.
          "
          fi
          
          BODY="${BODY}
          
          ### Automated Workflow
          1. ‚úÖ PR created automatically
          2. ‚è≥ Linting and tests will run via comprehensive-pr-automation and auto-pr-handler workflows
          3. ‚è≥ Security checks will be performed
          4. ‚è≥ Auto-merge will be enabled if all checks pass
          5. ‚è≥ Post-merge validation and summary will be generated
          
          ---
          
          *This is an automated PR. The branch will be merged to main once all required checks pass.*
          *Generated by: \`auto-create-branch-prs.yml\`*
          "
          
          # Save to outputs (escape newlines for GitHub Actions)
          echo "title=$TITLE" >> $GITHUB_OUTPUT
          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        id: create-pr
        if: steps.branch-info.outputs.skip_pr != 'true'
        uses: actions/github-script@v7
        env:
          PR_TITLE: ${{ steps.pr-content.outputs.title }}
          PR_BODY: ${{ steps.pr-content.outputs.body }}
        with:
          script: |
            const branch = '${{ matrix.branch }}';
            const title = process.env.PR_TITLE;
            const body = process.env.PR_BODY;
            const hasConflicts = '${{ env.CONFLICTS_PRESENT }}' === 'true';
            
            try {
              // Create the PR
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                head: branch,
                base: 'main'
              });
              
              console.log(`‚úÖ Created PR #${pr.number} for branch ${branch}`);
              core.setOutput('pr_number', pr.number);
              core.setOutput('pr_url', pr.html_url);
              
              // Add labels
              const labels = ['automated', 'auto-created'];
              if (hasConflicts) {
                labels.push('conflicts', 'needs-manual-review');
              } else {
                labels.push('auto-merge', 'ready-for-review');
              }
              
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: labels
              });
              
              console.log(`‚úÖ Added labels: ${labels.join(', ')}`);
              
              // Add comment with additional info
              const comment = hasConflicts
                ? `‚ö†Ô∏è **Manual Attention Required**\n\nThis PR has merge conflicts that need manual resolution. Please resolve the conflicts before merging.`
                : `‚úÖ **Ready for Automated Processing**\n\nThis PR will now go through automated review and testing. If all checks pass, it will be automatically merged.`;
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: comment
              });
              
              return { success: true, pr_number: pr.number, pr_url: pr.html_url };
              
            } catch (error) {
              if (error.message.includes('A pull request already exists')) {
                console.log(`‚ÑπÔ∏è PR already exists for branch ${branch}`);
                core.setOutput('skipped', 'true');
                return { success: false, reason: 'already_exists' };
              }
              throw error;
            }

      - name: Update summary
        if: always()
        run: |
          echo "### PR Status: ${{ matrix.branch }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.branch-info.outputs.skip_pr }}" = "true" ]; then
            echo "‚è≠Ô∏è **Skipped** - Branch has no commits ahead of main (only ${{ steps.branch-info.outputs.behind_by }} commits behind)" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.create-pr.outputs.skipped }}" = "true" ]; then
            echo "‚ÑπÔ∏è **Skipped** - PR already exists" >> $GITHUB_STEP_SUMMARY
          elif [ -n "${{ steps.create-pr.outputs.pr_number }}" ]; then
            echo "‚úÖ **Created** PR #${{ steps.create-pr.outputs.pr_number }}" >> $GITHUB_STEP_SUMMARY
            echo "üîó ${{ steps.create-pr.outputs.pr_url }}" >> $GITHUB_STEP_SUMMARY
            
            if [ "${{ env.CONFLICTS_PRESENT }}" = "true" ]; then
              echo "‚ö†Ô∏è Has merge conflicts - needs manual resolution" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚úÖ No conflicts - ready for automated processing" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚ùå **Failed** to create PR" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

  summary-report:
    name: Generate Summary Report
    runs-on: ubuntu-latest
    needs: [discover-and-create-prs, create-prs]
    if: always()
    steps:
      - name: Generate final summary
        uses: actions/github-script@v7
        with:
          script: |
            const branchCount = ${{ needs.discover-and-create-prs.outputs.branch-count }};
            
            // Get all PRs created in the last hour
            const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
            const { data: recentPRs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              sort: 'created',
              direction: 'desc',
              per_page: 100
            });
            
            const automatedPRs = recentPRs.filter(pr => 
              pr.labels.some(label => label.name === 'auto-created') &&
              new Date(pr.created_at) > oneHourAgo
            );
            
            const report = `
            ## ü§ñ Auto-Create Branch PRs - Summary Report
            
            **Execution Time**: ${new Date().toISOString()}
            
            ### Results
            - **Branches Discovered**: ${branchCount}
            - **PRs Created**: ${automatedPRs.length}
            
            ### Created PRs
            ${automatedPRs.length > 0 ? automatedPRs.map(pr => 
              `- [#${pr.number}](${pr.html_url}) - ${pr.title} (${pr.head.ref})`
            ).join('\n') : '_No new PRs created_'}
            
            ### Next Steps
            - Automated review and testing will run on all new PRs
            - PRs without conflicts will be auto-merged when checks pass
            - PRs with conflicts require manual resolution
            
            ---
            
            *Generated by: auto-create-branch-prs.yml*
            `;
            
            // Create an issue with the summary
            if (automatedPRs.length > 0) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `üìä Auto-PR Creation Summary - ${new Date().toISOString().split('T')[0]}`,
                body: report,
                labels: ['automated', 'summary', 'documentation']
              });
            }
            
            console.log(report);

  # Monitor workflow and create alerts for failures
  monitor-workflow:
    name: Monitor Workflow Health
    runs-on: ubuntu-latest
    needs: [discover-and-create-prs, create-prs, summary-report]
    if: failure()
    steps:
      - name: Create failure alert
        uses: actions/github-script@v7
        with:
          script: |
            const alert = `
            ## ‚ö†Ô∏è Auto-Create Branch PRs Workflow Failed
            
            **Time**: ${new Date().toISOString()}
            **Workflow**: auto-create-branch-prs.yml
            **Run**: ${context.runId}
            
            ### Action Required
            Please review the workflow logs and investigate the failure.
            
            [View Workflow Run](${context.payload.repository.html_url}/actions/runs/${context.runId})
            `;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'üö® Auto-PR Creation Workflow Failed',
              body: alert,
              labels: ['automated', 'workflow-failure', 'urgent']
            });
