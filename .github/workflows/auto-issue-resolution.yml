name: Auto Issue Resolution

on:
  issues:
    types: [labeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to attempt resolution'
        required: true
        type: number

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  attempt-resolution:
    name: Attempt Automatic Resolution
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' || 
      (github.event.action == 'labeled' && 
       (contains(github.event.label.name, 'security') || 
        contains(github.event.label.name, 'bug') || 
        contains(github.event.label.name, 'documentation')))
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Get Issue Details
        id: issue
        uses: actions/github-script@v7
        with:
          script: |
            let issueNumber;
            if (context.eventName === 'workflow_dispatch') {
              issueNumber = ${{ github.event.inputs.issue_number }};
            } else {
              issueNumber = context.issue.number;
            }
            
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            core.setOutput('number', issue.number);
            core.setOutput('title', issue.title);
            core.setOutput('body', issue.body || '');
            core.setOutput('labels', issue.labels.map(l => l.name).join(','));
            
            console.log(`Processing issue #${issue.number}: ${issue.title}`);
            return issue;

      - name: Attempt Security Fix
        if: contains(steps.issue.outputs.labels, 'security')
        run: |
          echo "Attempting to fix security issue #${{ steps.issue.outputs.number }}"
          
          # Install security tools
          python -m pip install --upgrade pip
          pip install pip-audit safety
          
          # Run pip-audit to find vulnerabilities
          pip-audit --format json -o vulnerabilities.json || true
          
          if [ -s vulnerabilities.json ]; then
            # Extract vulnerable packages and try to upgrade
            python3 << 'EOF'
          import json
          import subprocess
          import sys
          
          try:
              with open('vulnerabilities.json', 'r') as f:
                  data = json.load(f)
              
              packages_to_upgrade = {}
              for dep in data.get('dependencies', []):
                  if dep.get('vulns'):
                      pkg_name = dep.get('name')
                      # Get the minimum fix version
                      fix_versions = []
                      for vuln in dep['vulns']:
                          if vuln.get('fix_versions'):
                              fix_versions.extend(vuln['fix_versions'])
                      
                      if fix_versions:
                          # Use the latest fix version
                          packages_to_upgrade[pkg_name] = sorted(fix_versions)[-1]
              
              if packages_to_upgrade:
                  print(f"Found {len(packages_to_upgrade)} packages to upgrade:")
                  with open('upgrade-plan.txt', 'w') as f:
                      for pkg, version in packages_to_upgrade.items():
                          print(f"  - {pkg} -> {version}")
                          f.write(f"{pkg}=={version}\n")
                  
                  # Try to update requirements.txt if it exists
                  try:
                      with open('requirements.txt', 'r') as f:
                          reqs = f.readlines()
                      
                      updated = False
                      for i, line in enumerate(reqs):
                          for pkg in packages_to_upgrade:
                              if line.strip().startswith(pkg):
                                  reqs[i] = f"{pkg}=={packages_to_upgrade[pkg]}\n"
                                  updated = True
                                  break
                      
                      if updated:
                          with open('requirements.txt', 'w') as f:
                              f.writelines(reqs)
                          print("‚úì Updated requirements.txt")
                      else:
                          print("‚Ñπ No matching entries in requirements.txt")
                  except FileNotFoundError:
                      print("‚Ñπ requirements.txt not found")
                  
                  sys.exit(0)
              else:
                  print("No fix versions available")
                  sys.exit(1)
          except Exception as e:
              print(f"Error: {e}")
              sys.exit(1)
          EOF
            
            if [ $? -eq 0 ] && [ -f upgrade-plan.txt ]; then
              echo "FIX_AVAILABLE=true" >> $GITHUB_ENV
              echo "Fix plan created successfully"
            else
              echo "FIX_AVAILABLE=false" >> $GITHUB_ENV
              echo "No automated fix available"
            fi
          else
            echo "FIX_AVAILABLE=false" >> $GITHUB_ENV
            echo "No vulnerabilities found"
          fi

      - name: Attempt Documentation Fix
        if: contains(steps.issue.outputs.labels, 'documentation')
        run: |
          echo "Analyzing documentation issue #${{ steps.issue.outputs.number }}"
          
          # Simple documentation fixes could be attempted here
          # For now, we just log the attempt
          echo "DOC_FIX_AVAILABLE=false" >> $GITHUB_ENV
          echo "Documentation fixes require manual review"

      - name: Create PR for Fix
        if: env.FIX_AVAILABLE == 'true'
        uses: peter-evans/create-pull-request@v5
        id: create-pr
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: |
            üîí Auto-fix security vulnerabilities from issue #${{ steps.issue.outputs.number }}
            
            This PR automatically updates packages with known security vulnerabilities.
            
            Resolves #${{ steps.issue.outputs.number }}
          title: 'üîí Security: Auto-fix vulnerabilities (Issue #${{ steps.issue.outputs.number }})'
          body: |
            ## Automated Security Fix
            
            This PR was automatically created to resolve security vulnerabilities identified in issue #${{ steps.issue.outputs.number }}.
            
            ### Changes
            
            Updated the following packages to fix known vulnerabilities:
            
            ```
            $(cat upgrade-plan.txt 2>/dev/null || echo "See diff for details")
            ```
            
            ### Verification Required
            
            - [ ] All tests must pass
            - [ ] Review dependency changes for compatibility
            - [ ] Check for breaking changes in updated packages
            
            ### Related Issue
            
            Closes #${{ steps.issue.outputs.number }}
            
            ---
            
            **Note**: This is an automated PR. Please review carefully before merging.
            The automated system will close the original issue once this PR is merged.
          branch: auto-fix-issue-${{ steps.issue.outputs.number }}
          labels: security, dependencies, automated, auto-merge
          delete-branch: true

      - name: Comment on Issue
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ steps.issue.outputs.number }};
            const labels = '${{ steps.issue.outputs.labels }}'.split(',');
            
            let comment = 'ü§ñ **Automated Resolution Attempt**\n\n';
            
            if ('${{ env.FIX_AVAILABLE }}' === 'true' && '${{ steps.create-pr.outputs.pull-request-number }}') {
              comment += `‚úÖ An automated fix has been prepared!\n\n`;
              comment += `A pull request (#${{ steps.create-pr.outputs.pull-request-number }}) has been created to resolve this issue.\n\n`;
              comment += `**Next Steps:**\n`;
              comment += `1. The CI/CD pipeline will run tests on the PR\n`;
              comment += `2. If tests pass, the PR may be auto-approved\n`;
              comment += `3. A maintainer should review the changes\n`;
              comment += `4. Once merged, this issue will be automatically closed\n\n`;
              comment += `PR: #${{ steps.create-pr.outputs.pull-request-number }}`;
            } else if (labels.includes('security')) {
              comment += `‚ÑπÔ∏è Automated fix could not be prepared for this security issue.\n\n`;
              comment += `**Possible reasons:**\n`;
              comment += `- No fix versions available yet\n`;
              comment += `- Complex fix requiring manual intervention\n`;
              comment += `- Package not found in requirements\n\n`;
              comment += `This issue requires manual investigation and resolution.`;
            } else if (labels.includes('documentation')) {
              comment += `‚ÑπÔ∏è Documentation fixes require manual review.\n\n`;
              comment += `A maintainer will review and update the documentation as needed.`;
            } else {
              comment += `‚ÑπÔ∏è No automated resolution available for this issue.\n\n`;
              comment += `This issue requires manual investigation and resolution.`;
            }
            
            comment += '\n\n---\n*Automated by issue resolution system*';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: comment
            });
