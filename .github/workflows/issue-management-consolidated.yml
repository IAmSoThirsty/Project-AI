name: Issue Management - Consolidated

on:
  issues:
    types: [opened, reopened, labeled]
  schedule:
    # Run daily at 3 AM UTC
    - cron: '0 3 * * *'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: write
  security-events: read

jobs:
  # =========================================================================
  # TRIAGE AND CATEGORIZE ISSUES
  # =========================================================================
  triage-issues:
    name: Triage Issues
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # pinned from actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Update submodules
        run: git submodule update --init --recursive

      - name: Set up Python
        uses: actions/setup-python@0ae58b7817e9b40c6232e8bf08f42a7a6b8e60ec  # pinned from actions/setup-python@v4
        with:
          python-version: '3.11'

      # ========================================================================
      # DEPENDENCY INSTALLATION - Install ALL project dependencies
      # No conditionals, no ambiguity - just install everything to ensure
      # workflows work reliably every time
      # ========================================================================
      
      - name: Upgrade pip and build tools
        run: |
          echo "ðŸ“¦ Upgrading pip, setuptools, wheel, and build tools..."
          python -m pip install --upgrade pip setuptools wheel build
          echo "âœ… Build tools upgraded"

      - name: Install requirements.txt
        run: |
          echo "ðŸ“¦ Installing requirements.txt..."
          if [ -f requirements.txt ]; then
            python -m pip install -r requirements.txt
            echo "âœ… requirements.txt installed"
          else
            echo "âš ï¸  requirements.txt not found - skipping"
          fi

      - name: Install requirements-dev.txt
        run: |
          echo "ðŸ“¦ Installing requirements-dev.txt..."
          if [ -f requirements-dev.txt ]; then
            python -m pip install -r requirements-dev.txt
            echo "âœ… requirements-dev.txt installed"
          else
            echo "âš ï¸  requirements-dev.txt not found - skipping"
          fi

      - name: Install from pyproject.toml
        run: |
          echo "ðŸ“¦ Installing from pyproject.toml..."
          if [ -f pyproject.toml ]; then
            # Try pip install first (works for PEP 621 compliant pyproject.toml)
            python -m pip install -e . || echo "âš ï¸  pip install from pyproject.toml failed, continuing..."
            echo "âœ… pyproject.toml dependencies processed"
          else
            echo "âš ï¸  pyproject.toml not found - skipping"
          fi

      - name: Install from setup.py
        run: |
          echo "ðŸ“¦ Installing from setup.py..."
          if [ -f setup.py ]; then
            python -m pip install -e .
            echo "âœ… setup.py installed"
          else
            echo "âš ï¸  setup.py not found - skipping"
          fi

      - name: Install additional tools
        run: |
          echo "ðŸ“¦ Installing additional tools..."
          python -m pip install PyGithub requests pip-audit safety
          echo "âœ… Additional tools installed"

      - name: Triage and resolve issues
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea  # pinned from actions/github-script@v7
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const fs = require('fs');
            
            // Get all open issues
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });
            
            console.log(`Processing ${issues.length} open issue(s)...`);
            
            for (const issue of issues) {
              console.log(`\nProcessing issue #${issue.number}: ${issue.title}`);
              
              const issueBody = issue.body || '';
              const issueTitle = issue.title.toLowerCase();
              const issueBodyLower = issueBody.toLowerCase();
              
              // Skip pull requests
              if (issue.pull_request) {
                console.log(`  Skipping PR #${issue.number}`);
                continue;
              }
              
              // Category detection
              let category = 'other';
              let shouldClose = false;
              let closeReason = '';
              let shouldLabel = [];
              let priority = 'medium';
              
              // Security issue detection
              if (issueTitle.includes('security') || issueTitle.includes('vulnerability') || 
                  issueTitle.includes('cve-') || issueBodyLower.includes('security alert')) {
                category = 'security';
                shouldLabel.push('security');
                
                // Check if this is a false positive security report
                if (issueBodyLower.includes('0 vulnerability(ies)') || 
                    issueBodyLower.includes('0 vulnerabilities')) {
                  
                  const zeroVulnMatches = issueBody.match(/0 vulnerability\(ies\)/g) || [];
                  const packageMatches = issueBody.match(/\*\*[^*]+\*\*/g) || [];
                  
                  if (zeroVulnMatches.length >= 10 && zeroVulnMatches.length >= packageMatches.length * 0.8) {
                    shouldClose = true;
                    closeReason = 'False positive: Security scan reported 0 vulnerabilities for all packages. No action required.';
                    shouldLabel.push('false-positive', 'automated');
                    console.log(`  Detected false positive security report`);
                  }
                } else if (issueBodyLower.includes('vulnerability') || issueBodyLower.includes('cve-')) {
                  priority = 'high';
                  console.log(`  Real security vulnerability detected - high priority`);
                }
              }
              
              // Bug report detection
              if (issueTitle.includes('bug') || issueTitle.includes('error') || 
                  issueTitle.includes('issue') || issueTitle.includes('problem')) {
                if (category === 'other') category = 'bug';
                shouldLabel.push('bug');
              }
              
              // Feature request detection
              if (issueTitle.includes('feature') || issueTitle.includes('enhancement') || 
                  issueTitle.includes('request')) {
                if (category === 'other') category = 'feature';
                shouldLabel.push('enhancement');
                priority = 'low';
              }
              
              // Documentation issue detection
              if (issueTitle.includes('documentation') || issueTitle.includes('docs') || 
                  issueTitle.includes('readme')) {
                if (category === 'other') category = 'documentation';
                shouldLabel.push('documentation');
              }
              
              // Stale issue detection (30+ days old with no activity)
              const daysOld = Math.floor((Date.now() - new Date(issue.updated_at)) / (1000 * 60 * 60 * 24));
              if (daysOld > 30 && !shouldClose) {
                shouldLabel.push('stale');
                console.log(`  Issue is ${daysOld} days old without updates`);
                
                // Auto-close stale issues after 60 days
                if (daysOld > 60) {
                  shouldClose = true;
                  closeReason = 'Stale: This issue has been inactive for over 60 days and is being automatically closed. If this is still relevant, please reopen.';
                }
              }
              
              // Apply labels
              const currentLabels = issue.labels.map(l => l.name);
              const labelsToAdd = shouldLabel.filter(l => !currentLabels.includes(l));
              
              if (labelsToAdd.length > 0) {
                console.log(`  Adding labels: ${labelsToAdd.join(', ')}`);
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: labelsToAdd
                });
              }
              
              // Close issue if needed
              if (shouldClose) {
                console.log(`  Closing issue #${issue.number}: ${closeReason}`);
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: `ðŸ¤– **Automated Resolution**\n\n${closeReason}\n\n---\n*Automatically triaged by issue management system.*`
                });
                
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  state: 'closed',
                  state_reason: 'not_planned'
                });
              } else {
                // Add triage comment for open issues
                const comments = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number
                });
                
                const hasTriageComment = comments.data.some(c => 
                  c.body && c.body.includes('Automated Triage')
                );
                
                if (!hasTriageComment && category !== 'other') {
                  const triageMessage = `ðŸ¤– **Automated Triage**\n\n` +
                    `**Category**: ${category}\n` +
                    `**Priority**: ${priority}\n` +
                    `**Labels**: ${shouldLabel.join(', ') || 'none'}\n\n` +
                    `This issue has been automatically categorized and labeled.\n\n` +
                    `---\n*Automated by issue management system*`;
                  
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: triageMessage
                  });
                  
                  console.log(`  Added triage comment`);
                }
              }
            }
            
            console.log('\nâœ… Issue triage complete');

  # =========================================================================
  # GENERATE SUMMARY REPORT
  # =========================================================================
  generate-summary:
    name: Generate Summary
    runs-on: ubuntu-latest
    needs: triage-issues
    if: always()
    steps:
      - name: Generate summary report
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea  # pinned from actions/github-script@v7
        with:
          script: |
            const { data: openIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });
            
            const { data: closedToday } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              since: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
              per_page: 100
            });
            
            const categories = {};
            for (const issue of openIssues) {
              if (issue.pull_request) continue;
              const labels = issue.labels.map(l => l.name);
              const category = labels.find(l => ['security', 'bug', 'enhancement', 'documentation'].includes(l)) || 'uncategorized';
              categories[category] = (categories[category] || 0) + 1;
            }
            
            let summary = '## ðŸ“Š Issue Management Summary\n\n';
            summary += `**Total Open Issues**: ${openIssues.filter(i => !i.pull_request).length}\n`;
            summary += `**Issues Closed Today**: ${closedToday.filter(i => !i.pull_request).length}\n\n`;
            summary += '### Open Issues by Category\n';
            for (const [cat, count] of Object.entries(categories)) {
              summary += `- **${cat}**: ${count}\n`;
            }
            summary += `\n*Report generated at ${new Date().toISOString()}*\n`;
            
            console.log(summary);
            core.summary.addRaw(summary);
            await core.summary.write();
